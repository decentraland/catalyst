import { EntityType, Pointer, EntityId, Entity } from "@katalyst/content/service/Entity";
import { happenedBefore } from "@katalyst/content/service/time/TimeSorting";
import { CacheManager, POINTERS_CACHE_CONFIG } from "@katalyst/content/service/caching/CacheManager";
import { CacheByType } from "@katalyst/content/service/caching/Cache"
import { LastDeployedPointersRepository } from "@katalyst/content/storage/repositories/LastDeployedPointersRepository";
import { DeploymentId } from "@katalyst/content/storage/repositories/DeploymentsRepository";
import { PointerHistoryRepository } from "@katalyst/content/storage/repositories/PointerHistoryRepository";

/**
 * Manage all pointer data
 */
export class PointerManager {

    private readonly pointers: CacheByType<Pointer, EntityId>
    constructor(cacheManager: CacheManager) {
        this.pointers = cacheManager.buildEntityTypedCache(POINTERS_CACHE_CONFIG)
    }

    getActivePointers(lastDeployedPointersRepo: LastDeployedPointersRepository, entityType: EntityType, pointers: Pointer[]): Promise<EntityId[]> {
        return this.pointers.get(entityType, pointers, (entityType, pointers) => lastDeployedPointersRepo.getActiveDeploymentsOnPointers(entityType, pointers))
    }

    /**
     * Commit a new entity, and return the 'before & after' generated by the deployment
     */
    async referenceEntityFromPointers(lastDeployedPointersRepo: LastDeployedPointersRepository, deploymentId: DeploymentId, entity: Entity): Promise<DeploymentResult> {
        // Fetch last deployments on pointers
        const lastDeployments = await lastDeployedPointersRepo.getLastDeploymentsOnPointers(entity.type, entity.pointers)

        // Determine if the entity being deployed will become active
        const entityBeingDeployed = { entityId: entity.id, timestamp: entity.timestamp }
        const willDeploymentBecomeActive = lastDeployments.every(lastDeployment => happenedBefore(lastDeployment, entityBeingDeployed))

        // Prepare variables
        const result: Map<Pointer, { before: EntityId | undefined, after: EntityId | undefined }> = new Map()
        const overwrite: Set<Pointer> = new Set()

        lastDeployments.forEach(lastDeployment => {
            // Calculate the intersection of pointers between the last deployment and the new one
            const intersection: Set<Pointer> = intersect(lastDeployment.pointers, entity.pointers)

            if (happenedBefore(lastDeployment, entityBeingDeployed)) {
                intersection.forEach(pointer => {
                    // If this deployment happened before, then the intersected pointers will point either to the new entity, or to nothing
                    result.set(pointer, {
                        before: !lastDeployment.deleted ? lastDeployment.entityId : undefined,
                        after: willDeploymentBecomeActive ? entity.id : undefined
                    })

                    // All pointers on the intersection will need to be overwritten
                    overwrite.add(pointer)
                })

                // If the last deployment wasn't already deleted, then the pointers not pointing to the new entity, will point to nothing
                if (!lastDeployment.deleted) {
                    const onlyOnLastDeployed: Set<Pointer> = diff(lastDeployment.pointers, entity.pointers)
                    onlyOnLastDeployed.forEach(pointer => result.set(pointer, { before: lastDeployment.entityId, after: undefined }))
                }
            } else {
                // If the new entity happened before the current last deployment, then the intersected pointers will continue pointing to whatever they were pointing to
                intersection.forEach(pointer => result.set(pointer, {
                    before: !lastDeployment.deleted ? lastDeployment.entityId : undefined,
                    after: !lastDeployment.deleted ? lastDeployment.entityId : undefined,
                }))
            }
        })

        // Calculate which of the currently active entities will de deleted
        await lastDeployedPointersRepo.setAsLastDeployedOnPointers(deploymentId, entity.type, Array.from(overwrite.values()))

        return result
    }

    calculateOverwrites(pointerHistoryRepo: PointerHistoryRepository, entity: Entity): Promise<{ overwrote: Set<DeploymentId>, overwrittenBy: DeploymentId | null}> {
        return pointerHistoryRepo.calculateOverwrites(entity)
    }

    addToHistory(pointerHistoryRepo: PointerHistoryRepository, deploymentId: DeploymentId, entity: Entity){
        return pointerHistoryRepo.addToHistory(deploymentId, entity)
    }
}

export type DeploymentResult = Map<Pointer, { before: EntityId | undefined, after: EntityId | undefined }>

function intersect(pointers1: Pointer[], pointers2: Pointer[]): Set<Pointer> {
    return new Set(pointers1.filter(pointer => pointers2.includes(pointer)))
}

function diff(pointers1: Pointer[], pointers2: Pointer[]): Set<Pointer> {
    return new Set(pointers1.filter(pointer => !pointers2.includes(pointer)))
}
