import { EntityType, Pointer, EntityId, Entity } from "@katalyst/content/service/Entity";
import { happenedBefore } from "@katalyst/content/service/time/TimeSorting";
import { CacheManager, POINTERS_CACHE_CONFIG } from "@katalyst/content/service/caching/CacheManager";
import { CacheByType } from "@katalyst/content/service/caching/Cache"
import { LastDeployedPointersRepository } from "@katalyst/content/storage/repositories/LastDeployedPointersRepository";
import { DeploymentId } from "@katalyst/content/storage/repositories/DeploymentsRepository";
import { PointerHistoryRepository } from "@katalyst/content/storage/repositories/PointerHistoryRepository";

/**
 * Manage all pointer data
 */
export class PointerManager {

    private readonly pointers: CacheByType<Pointer, EntityId>
    constructor(cacheManager: CacheManager) {
        this.pointers = cacheManager.buildEntityTypedCache(POINTERS_CACHE_CONFIG)
    }

    getActiveEntitiesInPointers(lastDeployedPointersRepo: LastDeployedPointersRepository, entityType: EntityType, pointers: Pointer[]): Promise<EntityId[]> {
        return this.pointers.get(entityType, pointers, (entityType, pointers) => lastDeployedPointersRepo.getActiveDeploymentsOnPointers(entityType, pointers))
    }

    /**
     * Commit a new entity, and return the 'before & after' generated by the deployment
     */
    async referenceEntityFromPointers(lastDeployedPointersRepo: LastDeployedPointersRepository, deploymentId: DeploymentId, entity: Entity): Promise<DeploymentResult> {
        // Fetch last deployments on pointers
        const lastDeployments = await lastDeployedPointersRepo.getLastDeploymentsOnPointers(entity.type, entity.pointers)

        // Add a made up deployments for the pointers where there was no deployment yet
        const pointersWithDeployments = lastDeployments.map(deployment => deployment.pointers)
            .reduce((accum, curr) => accum.concat(curr), [])
        const pointersWithoutDeployments = diff(entity.pointers, pointersWithDeployments)
        if (pointersWithoutDeployments.size > 0) {
            lastDeployments.push({
                entityId: 'NOT_GONNA_BE_USED',
                deployment: 0,
                timestamp: -1,
                pointers: Array.from(pointersWithoutDeployments.values()),
                deleted: true,
            })
        }

        // Determine if the entity being deployed will become active
        const entityBeingDeployed = { entityId: entity.id, timestamp: entity.timestamp }
        const willDeploymentBecomeActive = lastDeployments.every(lastDeployment => happenedBefore(lastDeployment, entityBeingDeployed))

        // Prepare variables
        const result: DeploymentResult = new Map()
        const overwrite: Set<Pointer> = new Set()

        lastDeployments.forEach(lastDeployment => {
            // Calculate the intersection of pointers between the last deployment and the new one
            const intersection: Set<Pointer> = intersect(lastDeployment.pointers, entity.pointers)

            if (happenedBefore(lastDeployment, entityBeingDeployed)) {
                intersection.forEach(pointer => {
                    // If the last deployment happened before, then the intersected pointers will point either to the new entity, or to nothing
                    if (!lastDeployment.deleted || willDeploymentBecomeActive) {
                        result.set(pointer, {
                            before: !lastDeployment.deleted ? lastDeployment.deployment : undefined,
                            after: willDeploymentBecomeActive ? DELTA_POINTER_RESULT.SET : DELTA_POINTER_RESULT.CLEARED
                        })
                    }

                    // All pointers on the intersection will need to be overwritten
                    overwrite.add(pointer)
                })

                // If the last deployment wasn't already deleted, then the pointers not pointing to the new entity, will point to nothing
                if (!lastDeployment.deleted) {
                    const onlyOnLastDeployed: Set<Pointer> = diff(lastDeployment.pointers, entity.pointers)
                    onlyOnLastDeployed.forEach(pointer => result.set(pointer, { before: lastDeployment.deployment, after: DELTA_POINTER_RESULT.CLEARED }))
                }
            }
        })

        // Overwrite the currently last entities that need to be overwritten
        await lastDeployedPointersRepo.setAsLastDeployedOnPointers(deploymentId, entity.type, Array.from(overwrite.values()))

        // Invalidate the pointers
        Array.from(result.keys())
            .forEach(pointer => this.pointers.invalidate(entity.type, pointer))

        return result
    }

    calculateOverwrites(pointerHistoryRepo: PointerHistoryRepository, entity: Entity): Promise<{ overwrote: Set<DeploymentId>, overwrittenBy: DeploymentId | null}> {
        return pointerHistoryRepo.calculateOverwrites(entity)
    }

    addToHistory(pointerHistoryRepo: PointerHistoryRepository, deploymentId: DeploymentId, entity: Entity){
        return pointerHistoryRepo.addToHistory(deploymentId, entity)
    }
}

export type DeploymentResult = Map<Pointer, { before: DeploymentId | undefined, after: DELTA_POINTER_RESULT }>

export enum DELTA_POINTER_RESULT {
    SET = 'set',
    CLEARED = 'cleared',
}

function intersect(pointers1: Pointer[], pointers2: Pointer[]): Set<Pointer> {
    return new Set(pointers1.filter(pointer => pointers2.includes(pointer)))
}

function diff(pointers1: Pointer[], pointers2: Pointer[]): Set<Pointer> {
    return new Set(pointers1.filter(pointer => !pointers2.includes(pointer)))
}
